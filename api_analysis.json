[
  {
    "http_method": "UNKNOWN",
    "parameters": [],
    "return_type": "unknown",
    "database_operations": [],
    "dafny_function": {
      "name": "delete",
      "preconditions": [
        "requires true"
      ],
      "postconditions": [
        "ensures true"
      ]
    },
    "raw_response": "## Analysis of the Django REST API Function\n\n### 1. HTTP Method\nThe HTTP method handled by this API function is `DELETE`.\n\n### 2. Parameters\nThe function does not explicitly accept any parameters. It operates on the instance it is called on.\n\n### 3. Return Type\nThe function does not return any value (or returns `None` by default).\n\n### 4. Database Operations\nThe function performs the following database operations:\n- Reads: It retrieves a queryset (`qs`) and an existing maximum sort order.\n- Writes/Updates: It updates the sort order of other records in the database.\n\n### 5. Business Logic\nThe business logic implemented here ensures that when a `SortableModel` instance is deleted, the sort orders of other instances with a higher sort order are adjusted to maintain a continuous sequence.\n\n## Dafny Function Specification\n\nGiven the analysis, here is a Dafny function specification:\n\n```json\n{\n  \"http_method\": \"DELETE\",\n  \"parameters\": [],\n  \"return_type\": \"None\",\n  \"database_operations\": [\"read\", \"update\", \"delete\"],\n  \"dafny_function\": {\n    \"name\": \"deleteSortableModel\",\n    \"preconditions\": [\n      \"requires this instanceof SortableModel; // Assuming SortableModel is defined in Dafny\",\n      \"requires this.sort_order != null ==> this.get_ordering_queryset().Any(x => x.sort_order > this.sort_order); // Ensuring higher sort orders exist if needed\"\n    ],\n    \"postconditions\": [\n      \"ensures !this.get_ordering_queryset().Any(x => x == this); // This instance is deleted\",\n      \"ensures forall qs :: this.get_ordering_queryset() == qs ==> qs.filter(x => x.sort_order > old(this.sort_order)).forall(x => x.sort_order == old(x.sort_order) - 1); // Adjust sort orders\"\n    ]\n  }\n}\n```\n\n## Explanation\n- The `deleteSortableModel` function in Dafny represents the `delete` method of the `SortableModel` class in Django.\n- **Preconditions (`requires` clauses):**\n  - The instance on which the method is called must be of type `SortableModel`.\n  - If the instance's `sort_order` is not null, there must exist at least one other instance in the ordering queryset with a sort order greater than this instance's sort order. This ensures that the update operation that decrements sort orders is valid.\n- **Postconditions (`ensures` clauses):**\n  - The instance is deleted from the database.\n  - For all querysets `qs` that represent the ordering queryset of the model, every instance `x` in `qs` with a sort order greater than the old sort order of the deleted instance now has a sort order that is one less than its old sort order. This ensures that the sort orders are correctly adjusted after deletion.",
    "original_api": {
      "name": "delete",
      "file": "/Users/ryanmarr/Documents/saleor/saleor/core/models.py",
      "content": "import datetime\nfrom collections.abc import Iterable\nfrom typing import Any, TypeVar\n\nfrom django.contrib.postgres.indexes import GinIndex, PostgresIndex\nfrom django.core.files.base import ContentFile\nfrom django.db import models, transaction\nfrom django.db.models import F, JSONField, Max, Q\nfrom django.utils.crypto import get_random_string\nfrom storages.utils import safe_join\n\nfrom . import EventDeliveryStatus, JobStatus, private_storage\nfrom .utils.json_serializer import CustomJsonEncoder\n\n\nclass SortableModel(models.Model):\n    sort_order = models.IntegerField(editable=False, db_index=True, null=True)\n\n    class Meta:\n        abstract = True\n\n    def get_ordering_queryset(self):\n        raise NotImplementedError(\"Unknown ordering queryset\")\n\n    @staticmethod\n    def get_max_sort_order(qs):\n        existing_max = qs.aggregate(Max(\"sort_order\"))\n        existing_max = existing_max.get(\"sort_order__max\")\n        return existing_max\n\n    def save(self, *args, **kwargs):\n        if self.pk is None:\n            qs = self.get_ordering_queryset()\n            existing_max = self.get_max_sort_order(qs)\n            self.sort_order = 0 if existing_max is None else existing_max + 1\n        super().save(*args, **kwargs)\n\n    @transaction.atomic\n    def delete(self, *args, **kwargs):\n        if self.sort_order is not None:\n            qs = self.get_ordering_queryset()\n            qs.filter(sort_order__gt=self.sort_order).update(\n                sort_order=F(\"sort_order\") - 1\n            )\n        super().delete(*args, **kwargs)\n\n\nT = TypeVar(\"T\", bound=\"PublishableModel\")\n\n\nclass PublishedQuerySet(models.QuerySet[T]):\n    def published(self):\n        today = datetime.datetime.now(tz=datetime.UTC)\n        return self.filter(\n            Q(published_at__lte=today) | Q(published_at__isnull=True),\n            is_published=True,\n        )\n\n\nPublishableManager = models.Manager.from_queryset(PublishedQuerySet)\n\n\nclass PublishableModel(models.Model):\n    published_at = models.DateTimeField(blank=True, null=True)\n    is_published = models.BooleanField(default=False)\n\n    objects: Any = PublishableManager()\n\n    class Meta:\n        abstract = True\n\n    @property\n    def is_visible(self):\n        return self.is_published and (\n            self.published_at is None\n            or self.published_at <= datetime.datetime.now(tz=datetime.UTC)\n        )\n\n\nclass ModelWithMetadata(models.Model):\n    private_metadata = JSONField(\n        blank=True, db_default={}, default=dict, encoder=CustomJsonEncoder\n    )\n    metadata = JSONField(\n        blank=True, db_default={}, default=dict, encoder=CustomJsonEncoder\n    )\n\n    class Meta:\n        indexes: list[PostgresIndex] = [\n            GinIndex(fields=[\"private_metadata\"], name=\"%(class)s_p_meta_idx\"),\n            GinIndex(fields=[\"metadata\"], name=\"%(class)s_meta_idx\"),\n        ]\n        abstract = True\n\n    def get_value_from_private_metadata(self, key: str, default: Any = None) -> Any:\n        return self.private_metadata.get(key, default)\n\n    def store_value_in_private_metadata(self, items: dict):\n        if not self.private_metadata:\n            self.private_metadata = {}\n        self.private_metadata.update(items)\n\n    def clear_private_metadata(self):\n        self.private_metadata = {}\n\n    def delete_value_from_private_metadata(self, key: str) -> bool:\n        if key in self.private_metadata:\n            del self.private_metadata[key]\n            return True\n        return False\n\n    def get_value_from_metadata(self, key: str, default: Any = None) -> Any:\n        return self.metadata.get(key, default)\n\n    def store_value_in_metadata(self, items: dict):\n        if not self.metadata:\n            self.metadata = {}\n        self.metadata.update(items)\n\n    def clear_metadata(self):\n        self.metadata = {}\n\n    def delete_value_from_metadata(self, key: str):\n        if key in self.metadata:\n            del self.metadata[key]\n\n\nclass ModelWithExternalReference(models.Model):\n    external_reference = models.CharField(\n        max_length=250,\n        unique=True,\n        blank=True,\n        null=True,\n        db_index=True,\n    )\n\n    class Meta:\n        abstract = True\n\n\nclass Job(models.Model):\n    status = models.CharField(\n        max_length=50, choices=JobStatus.CHOICES, default=JobStatus.PENDING\n    )\n    message = models.CharField(max_length=255, blank=True, null=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        abstract = True\n\n\nclass EventPayloadManager(models.Manager[\"EventPayload\"]):\n    @transaction.atomic\n    def create_with_payload_file(self, payload: str) -> \"EventPayload\":\n        obj = super().create()\n        obj.save_payload_file(payload)\n        return obj\n\n    @transaction.atomic\n    def bulk_create_with_payload_files(\n        self, objs: Iterable[\"EventPayload\"], payloads=Iterable[str]\n    ) -> list[\"EventPayload\"]:\n        created_objs = self.bulk_create(objs)\n        for obj, payload_data in zip(created_objs, payloads, strict=False):\n            obj.save_payload_file(payload_data, save_instance=False)\n        self.bulk_update(created_objs, [\"payload_file\"])\n        return created_objs\n\n\nclass EventPayload(models.Model):\n    PAYLOADS_DIR = \"payloads\"\n\n    payload = models.TextField(default=\"\")\n    payload_file = models.FileField(\n        storage=private_storage, upload_to=PAYLOADS_DIR, null=True\n    )\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    objects = EventPayloadManager()\n\n    # TODO (PE-568): change typing of return payload to `bytes` to avoid unnecessary decoding.\n    def get_payload(self):\n        if self.payload_file:\n            with self.payload_file.open(\"rb\") as f:\n                payload_data = f.read()\n                return payload_data.decode(\"utf-8\")\n        return self.payload\n\n    def save_payload_file(self, payload_data: str, save_instance=True):\n        payload_bytes = payload_data.encode(\"utf-8\")\n        prefix = get_random_string(length=12)\n        file_name = f\"{self.pk}.json\"\n        file_path = safe_join(prefix, file_name)\n        self.payload_file.save(\n            file_path, ContentFile(payload_bytes), save=save_instance\n        )\n\n    def save_as_file(self):\n        payload_data = self.payload\n        self.payload = \"\"\n        self.save()\n        self.save_payload_file(payload_data)\n\n\nclass EventDelivery(models.Model):\n    created_at = models.DateTimeField(auto_now_add=True)\n    status = models.CharField(\n        max_length=255,\n        choices=EventDeliveryStatus.CHOICES,\n        default=EventDeliveryStatus.PENDING,\n    )\n    event_type = models.CharField(max_length=255)\n    payload = models.ForeignKey(\n        EventPayload, related_name=\"deliveries\", null=True, on_delete=models.CASCADE\n    )\n    webhook = models.ForeignKey(\"webhook.Webhook\", on_delete=models.CASCADE)\n\n    class Meta:\n        ordering = (\"-created_at\",)\n\n\nclass EventDeliveryAttempt(models.Model):\n    delivery = models.ForeignKey(\n        EventDelivery, related_name=\"attempts\", null=True, on_delete=models.CASCADE\n    )\n    created_at = models.DateTimeField(auto_now_add=True)\n    task_id = models.CharField(max_length=255, null=True)\n    duration = models.FloatField(null=True)\n    response = models.TextField(null=True)\n    response_headers = models.TextField(null=True)\n    response_status_code = models.PositiveSmallIntegerField(null=True)\n    request_headers = models.TextField(null=True)\n    status = models.CharField(\n        max_length=255,\n        choices=EventDeliveryStatus.CHOICES,\n        default=EventDeliveryStatus.PENDING,\n    )\n\n    class Meta:\n        ordering = (\"-created_at\",)\n",
      "line": 39
    }
  },
  {
    "http_method": "UNKNOWN",
    "parameters": [],
    "return_type": "unknown",
    "database_operations": [],
    "dafny_function": {
      "name": "delete",
      "preconditions": [
        "requires true"
      ],
      "postconditions": [
        "ensures true"
      ]
    },
    "raw_response": "## Analysis of the Django REST API Function\n\n### 1. HTTP Method\nThe HTTP method handled by this API function is `DELETE`.\n\n### 2. Parameters\nThe function `delete` does not explicitly accept any parameters in the provided code snippet. However, it is likely that it operates on a model instance, which would be implicitly passed as `self`.\n\n### 3. Return Type\nThe return type of the `delete` method is not explicitly defined in the provided code snippet, but typically, Django's `delete` method does not return any value (or returns `None`).\n\n### 4. Database Operations\nThe database operation performed by this function is `delete`.\n\n### 5. Business Logic\nThe business logic implemented by this function seems to be related to deleting an instance of a model that inherits from `BaseAttributeQuerySet` or a similar model. However, without more context, it's hard to provide a detailed explanation.\n\n## Dafny Function Specification\n\nGiven the analysis, here is a Dafny function specification:\n\n```json\n{\n  \"http_method\": \"DELETE\",\n  \"parameters\": [],\n  \"return_type\": \"void\",\n  \"database_operations\": [\"delete\"],\n  \"dafny_function\": {\n    \"name\": \"DeleteAttribute\",\n    \"preconditions\": [\n      \"requires this != null\",\n      \"requires this.Valid()\"\n    ],\n    \"postconditions\": [\n      \"ensures !this.Valid()\",\n      \"ensures forall x :: !x.Valid() ==> x != this\"\n    ]\n  }\n}\n```\n\n### Explanation:\n\n- **http_method**: The HTTP method handled by the function.\n- **parameters**: The function does not explicitly take any parameters.\n- **return_type**: The function does not return any value.\n- **database_operations**: The function performs a delete operation on the database.\n- **dafny_function**:\n  - **name**: A name for the Dafny function that represents the `delete` method.\n  - **preconditions (requires clauses)**: \n    - `this != null` ensures that the object being deleted is not null.\n    - `this.Valid()` assumes that the object being deleted is in a valid state before deletion.\n  - **postconditions (ensures clauses)**:\n    - `!this.Valid()` ensures that after deletion, the object is no longer in a valid state.\n    - `forall x :: !x.Valid() ==> x != this` ensures that the deletion of `this` object does not affect the validity of other objects.\n\nNote that the Dafny specification assumes the existence of a `Valid` predicate that checks if an object is in a valid state, which is common in Dafny for representing object invariants. The actual implementation might vary based on how `Valid` is defined for the specific model types in Dafny.",
    "original_api": {
      "name": "delete",
      "file": "/Users/ryanmarr/Documents/saleor/saleor/attribute/models/base.py",
      "content": "from typing import TYPE_CHECKING, TypeVar, Union\n\nfrom django.contrib.postgres.indexes import BTreeIndex, GinIndex\nfrom django.db import models, transaction\nfrom django.db.models import Case, Exists, F, OrderBy, OuterRef, Q, Value, When\n\nfrom ...core.db.fields import SanitizedJSONField\nfrom ...core.models import ModelWithExternalReference, ModelWithMetadata, SortableModel\nfrom ...core.units import MeasurementUnits\nfrom ...core.utils.editorjs import clean_editor_js\nfrom ...core.utils.translations import Translation\nfrom ...page.models import Page, PageType\nfrom ...permission.enums import PageTypePermissions, ProductTypePermissions\nfrom ...permission.utils import has_one_of_permissions\nfrom ...product.models import Category, Collection, Product, ProductType, ProductVariant\nfrom .. import AttributeEntityType, AttributeInputType, AttributeType\n\nif TYPE_CHECKING:\n    from ...account.models import User\n    from ...app.models import App\n\n\nclass BaseAssignedAttribute(models.Model):\n    # TODO: stop using this class in new code\n    # See: https://github.com/saleor/saleor/issues/12881\n    class Meta:\n        abstract = True\n\n    @property\n    def attribute(self):\n        return self.assignment.attribute  # type: ignore[attr-defined] # mixin\n\n\nT = TypeVar(\"T\", bound=models.Model)\n\n\nclass BaseAttributeQuerySet(models.QuerySet[T]):\n    def get_public_attributes(self):\n        raise NotImplementedError\n\n    def get_visible_to_user(self, requestor: Union[\"User\", \"App\", None]):\n        if has_one_of_permissions(\n            requestor,\n            [\n                PageTypePermissions.MANAGE_PAGE_TYPES_AND_ATTRIBUTES,\n                ProductTypePermissions.MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES,\n            ],\n        ):\n            return self.all()\n        return self.get_public_attributes()\n\n\nclass AssociatedAttributeQuerySet(BaseAttributeQuerySet[T]):\n    def get_public_attributes(self):\n        attributes = Attribute.objects.filter(visible_in_storefront=True)\n        return self.filter(Exists(attributes.filter(id=OuterRef(\"attribute_id\"))))\n\n\nAssociatedAttributeManager = models.Manager.from_queryset(AssociatedAttributeQuerySet)\n\n\nclass AttributeQuerySet(BaseAttributeQuerySet[T]):\n    def get_unassigned_product_type_attributes(self, product_type_pk: int):\n        return self.product_type_attributes().exclude(\n            Q(attributeproduct__product_type_id=product_type_pk)\n            | Q(attributevariant__product_type_id=product_type_pk)\n        )\n\n    def get_unassigned_page_type_attributes(self, page_type_pk: int):\n        return self.page_type_attributes().exclude(\n            attributepage__page_type_id=page_type_pk\n        )\n\n    def get_assigned_product_type_attributes(self, product_type_pk: int):\n        return self.product_type_attributes().filter(\n            Q(attributeproduct__product_type_id=product_type_pk)\n            | Q(attributevariant__product_type_id=product_type_pk)\n        )\n\n    def get_assigned_page_type_attributes(self, product_type_pk: int):\n        return self.page_type_attributes().filter(\n            Q(attributepage__page_type_id=product_type_pk)\n        )\n\n    def get_public_attributes(self):\n        return self.filter(visible_in_storefront=True)\n\n    def _get_sorted_m2m_field(self, m2m_field_name: str, asc: bool):\n        sort_order_field = F(f\"{m2m_field_name}__sort_order\")\n        id_field = F(f\"{m2m_field_name}__id\")\n        if asc:\n            sort_method = sort_order_field.asc(nulls_last=True)\n            id_sort: OrderBy | F = id_field\n        else:\n            sort_method = sort_order_field.desc(nulls_first=True)\n            id_sort = id_field.desc()\n\n        return self.order_by(sort_method, id_sort)\n\n    def product_attributes_sorted(self, asc=True):\n        return self._get_sorted_m2m_field(\"attributeproduct\", asc)\n\n    def variant_attributes_sorted(self, asc=True):\n        return self._get_sorted_m2m_field(\"attributevariant\", asc)\n\n    def product_type_attributes(self):\n        return self.filter(type=AttributeType.PRODUCT_TYPE)\n\n    def page_type_attributes(self):\n        return self.filter(type=AttributeType.PAGE_TYPE)\n\n\nAttributeManager = models.Manager.from_queryset(AttributeQuerySet)\n\n\nclass Attribute(ModelWithMetadata, ModelWithExternalReference):\n    slug = models.SlugField(max_length=250, unique=True, allow_unicode=True)\n    name = models.CharField(max_length=255)\n    type = models.CharField(max_length=50, choices=AttributeType.CHOICES)\n\n    input_type = models.CharField(\n        max_length=50,\n        choices=AttributeInputType.CHOICES,\n        default=AttributeInputType.DROPDOWN,\n    )\n    entity_type = models.CharField(\n        max_length=50, choices=AttributeEntityType.CHOICES, blank=True, null=True\n    )\n\n    product_types = models.ManyToManyField(\n        ProductType,\n        blank=True,\n        related_name=\"product_attributes\",\n        through=\"attribute.AttributeProduct\",\n        through_fields=(\"attribute\", \"product_type\"),\n    )\n    product_variant_types = models.ManyToManyField(\n        ProductType,\n        blank=True,\n        related_name=\"variant_attributes\",\n        through=\"attribute.AttributeVariant\",\n        through_fields=(\"attribute\", \"product_type\"),\n    )\n    page_types = models.ManyToManyField(\n        PageType,\n        blank=True,\n        related_name=\"page_attributes\",\n        through=\"attribute.AttributePage\",\n        through_fields=(\"attribute\", \"page_type\"),\n    )\n\n    unit = models.CharField(\n        max_length=100,\n        # MeasurementUnits is constructed programmatically, so mypy can't see its fields\n        choices=MeasurementUnits.CHOICES,  # type: ignore[attr-defined]\n        blank=True,\n        null=True,\n    )\n    value_required = models.BooleanField(default=False, blank=True)\n    is_variant_only = models.BooleanField(default=False, blank=True)\n    visible_in_storefront = models.BooleanField(default=True, blank=True)\n\n    filterable_in_storefront = models.BooleanField(default=False, blank=True)\n    filterable_in_dashboard = models.BooleanField(default=False, blank=True)\n\n    storefront_search_position = models.IntegerField(default=0, blank=True)\n    available_in_grid = models.BooleanField(default=False, blank=True)\n    max_sort_order = models.IntegerField(default=None, null=True, blank=True)\n\n    objects = AttributeManager()\n\n    class Meta(ModelWithMetadata.Meta):\n        ordering = (\"storefront_search_position\", \"slug\")\n        indexes = [\n            *ModelWithMetadata.Meta.indexes,\n            GinIndex(\n                name=\"attribute_gin\",\n                # `opclasses` and `fields` should be the same length\n                fields=[\"slug\", \"name\", \"type\", \"input_type\", \"entity_type\", \"unit\"],\n                opclasses=[\"gin_trgm_ops\"] * 6,\n            ),\n        ]\n\n    def __str__(self) -> str:\n        return self.name\n\n    def has_values(self) -> bool:\n        return self.values.exists()\n\n\nclass AttributeTranslation(Translation):\n    attribute = models.ForeignKey(\n        Attribute, related_name=\"translations\", on_delete=models.CASCADE\n    )\n    name = models.CharField(max_length=255)\n\n    class Meta:\n        unique_together = ((\"language_code\", \"attribute\"),)\n\n    def __repr__(self):\n        class_ = type(self)\n        return f\"{class_.__name__}(pk={self.pk!r}, name={self.name!r}, attribute_pk={self.attribute_id!r})\"\n\n    def __str__(self) -> str:\n        return self.name\n\n    def get_translated_object_id(self):\n        return \"Attribute\", self.attribute_id\n\n    def get_translated_keys(self):\n        return {\"name\": self.name}\n\n\nclass AttributeValueManager(models.Manager):\n    def _prepare_query_for_bulk_operation(self, objects_data):\n        query_params = models.Q()\n\n        for obj in objects_data:\n            defaults = obj.pop(\"defaults\")\n            query_params |= models.Q(**obj)\n            obj[\"defaults\"] = defaults\n\n        return self.filter(query_params)\n\n    def _is_correct_record(self, record, obj):\n        is_correct_record = (\n            getattr(record, field_name) == field_value\n            for field_name, field_value in obj.items()\n            if field_name != \"defaults\"\n        )\n        return all(is_correct_record)\n\n    def bulk_get_or_create(self, objects_data):\n        # this method mimics django's queryset.get_or_create method on bulk objects\n        # instead of performing it one by one\n        # https://docs.djangoproject.com/en/5.0/ref/models/querysets/#get-or-create\n\n        results = []\n        objects_not_in_db: list[AttributeValue] = []\n\n        # prepare a list that will save order index of attribute values\n        objects_enumerated = list(enumerate(objects_data))\n        query = self._prepare_query_for_bulk_operation(objects_data)\n\n        # iterate over all records in db and check if they match any of objects data\n        for record in query.iterator(chunk_size=1000):\n            # iterate over all objects data and check if they match any of records in db\n            for index, obj in objects_enumerated:\n                if self._is_correct_record(record, obj):\n                    # upon finding existing record add it to results\n                    results.append((index, record))\n                    # remove it from objects list, so it won't be added to new records\n                    objects_enumerated.remove((index, obj))\n\n                    break\n\n        # add what is left to the list of new records\n        self._add_new_records(objects_enumerated, objects_not_in_db, results)\n        # sort results by index as db record order might be different from sort_order\n        results.sort()\n        results = [obj for index, obj in results]\n\n        if objects_not_in_db:\n            # After migrating to Django 4.0 we should use `update_conflicts` instead\n            # of `ignore_conflicts`\n            # https://docs.djangoproject.com/en/4.1/ref/models/querysets/#bulk-create\n            self.bulk_create(\n                objects_not_in_db,  # type: ignore[arg-type]\n                ignore_conflicts=True,\n            )\n\n        return results\n\n    def bulk_update_or_create(self, objects_data):\n        # this method mimics django's queryset.update_or_create method on bulk objects\n        # https://docs.djangoproject.com/en/5.0/ref/models/querysets/#update-or-create\n        results = []\n        objects_not_in_db: list[AttributeValue] = []\n        objects_to_be_updated = []\n        update_fields = set()\n        objects_enumerated = list(enumerate(objects_data))\n        query = self._prepare_query_for_bulk_operation(objects_data)\n\n        # iterate over all records in db and check if they match any of objects data\n        for record in query.iterator(chunk_size=1000):\n            # iterate over all objects data and check if they match any of records in db\n            for index, obj in objects_enumerated:\n                if self._is_correct_record(record, obj):\n                    # upon finding a matching record, update it with defaults\n                    for key, value in obj[\"defaults\"].items():\n                        setattr(record, key, value)\n                        update_fields.add(key)\n\n                    # add it to results and objects to be updated\n                    results.append((index, record))\n\n                    # add it to objects to be updated, so it can be bulk updated later\n                    objects_to_be_updated.append(record)\n\n                    # remove it from objects data, so it won't be added to new records\n                    objects_enumerated.remove((index, obj))\n\n                    break\n\n        # add what is left to the list of new records\n        self._add_new_records(objects_enumerated, objects_not_in_db, results)\n\n        # sort results by index as db record order might be different from sort_order\n        results.sort()\n        results = [obj for index, obj in results]\n\n        if objects_not_in_db:\n            # After migrating to Django 4.0 we should use `update_conflicts` instead\n            # of `ignore_conflicts`\n            # https://docs.djangoproject.com/en/4.1/ref/models/querysets/#bulk-create\n            self.bulk_create(\n                objects_not_in_db,  # type: ignore[arg-type]\n                ignore_conflicts=True,\n            )\n\n        if objects_to_be_updated:\n            from ..lock_objects import attribute_value_qs_select_for_update\n\n            with transaction.atomic():\n                _locked_qs = (\n                    attribute_value_qs_select_for_update()\n                    .filter(pk__in=[obj.pk for obj in objects_to_be_updated])\n                    .select_for_update(of=([\"self\"]))\n                )\n                self.bulk_update(\n                    objects_to_be_updated,\n                    fields=update_fields,\n                )\n\n        return results\n\n    def _add_new_records(self, objects_enumerated, objects_not_in_db, results):\n        for index, obj in objects_enumerated:\n            # updating object data with defaults as they contain new values\n            defaults = obj.pop(\"defaults\")\n            obj.update(defaults)\n\n            # add new record to the list of new records, so it can be bulk created later\n            record = self.model(**obj)\n            objects_not_in_db.append(record)\n            results.append((index, record))\n\n\nclass AttributeValue(ModelWithExternalReference):\n    name = models.CharField(max_length=250)\n    # keeps hex code color value in #RRGGBBAA format\n    value = models.CharField(max_length=255, blank=True, default=\"\")\n    slug = models.SlugField(max_length=255, allow_unicode=True)\n    file_url = models.URLField(null=True, blank=True)\n    content_type = models.CharField(max_length=50, null=True, blank=True)\n    attribute = models.ForeignKey(\n        Attribute, related_name=\"values\", on_delete=models.CASCADE\n    )\n    rich_text = SanitizedJSONField(blank=True, null=True, sanitizer=clean_editor_js)\n    plain_text = models.TextField(\n        blank=True,\n        null=True,\n    )\n    boolean = models.BooleanField(blank=True, null=True)\n    date_time = models.DateTimeField(blank=True, null=True)\n    numeric = models.FloatField(null=True, blank=True)\n\n    reference_product = models.ForeignKey(\n        Product,\n        related_name=\"references\",\n        on_delete=models.CASCADE,\n        null=True,\n        blank=True,\n    )\n\n    reference_variant = models.ForeignKey(\n        ProductVariant,\n        related_name=\"references\",\n        on_delete=models.CASCADE,\n        null=True,\n        blank=True,\n    )\n\n    reference_collection = models.ForeignKey(\n        Collection,\n        related_name=\"references\",\n        on_delete=models.CASCADE,\n        null=True,\n        blank=True,\n    )\n\n    reference_category = models.ForeignKey(\n        Category,\n        related_name=\"references\",\n        on_delete=models.CASCADE,\n        null=True,\n        blank=True,\n    )\n\n    reference_page = models.ForeignKey(\n        Page, related_name=\"references\", on_delete=models.CASCADE, null=True, blank=True\n    )\n\n    sort_order = models.IntegerField(editable=False, db_index=True, null=True)\n\n    objects = AttributeValueManager()\n\n    class Meta:\n        ordering = (\"sort_order\", \"pk\")\n        unique_together = (\"slug\", \"attribute\")\n        indexes = [\n            GinIndex(\n                name=\"attribute_search_gin\",\n                # `opclasses` and `fields` should be the same length\n                fields=[\"name\", \"slug\"],\n                opclasses=[\"gin_trgm_ops\"] * 2,\n            ),\n            BTreeIndex(\n                fields=[\"numeric\"],\n                name=\"attribute_value_numeric_idx\",\n            ),\n        ]\n\n    def __str__(self) -> str:\n        return self.name\n\n    @property\n    def input_type(self):\n        return self.attribute.input_type\n\n    def get_ordering_queryset(self):\n        return self.attribute.values.all()\n\n    @transaction.atomic\n    def save(self, *args, **kwargs):\n        if self.pk is None or self.sort_order is None:\n            self.set_current_sorting_order()\n\n        super().save(*args, **kwargs)\n\n    @transaction.atomic\n    def delete(self, *args, **kwargs):\n        if self.sort_order is not None:\n            qs = self.get_ordering_queryset()\n            if qs.filter(sort_order__gt=self.sort_order).update(\n                sort_order=F(\"sort_order\") - 1\n            ):\n                if self.attribute.max_sort_order is None:\n                    value = self._calculate_sort_order_value()\n                    self.attribute.max_sort_order = max(value - 1, 0)\n                    self.attribute.save(update_fields=[\"max_sort_order\"])\n                else:\n                    Attribute.objects.filter(pk=self.attribute.pk).update(\n                        max_sort_order=Case(\n                            When(\n                                Q(max_sort_order__gt=0),\n                                then=F(\"max_sort_order\") - 1,\n                            ),\n                            default=Value(0),\n                        )\n                    )\n\n        super().delete(*args, **kwargs)\n\n    def _calculate_sort_order_value(self):\n        qs = self.get_ordering_queryset()\n        existing_max = SortableModel.get_max_sort_order(qs)\n        return -1 if existing_max is None else existing_max\n\n    def _save_new_max_sort_order(self, value):\n        self.sort_order = value\n        self.attribute.max_sort_order = value\n        self.attribute.save(update_fields=[\"max_sort_order\"])\n\n    def set_current_sorting_order(self):\n        if self.attribute.max_sort_order is None:\n            value = self._calculate_sort_order_value()\n            self._save_new_max_sort_order(value + 1)\n        else:\n            Attribute.objects.filter(pk=self.attribute.pk).update(\n                max_sort_order=F(\"max_sort_order\") + 1\n            )\n            self.attribute.refresh_from_db()\n            self.sort_order = self.attribute.max_sort_order\n\n\nclass AttributeValueTranslation(Translation):\n    attribute_value = models.ForeignKey(\n        AttributeValue, related_name=\"translations\", on_delete=models.CASCADE\n    )\n    name = models.CharField(max_length=250)\n    rich_text = SanitizedJSONField(blank=True, null=True, sanitizer=clean_editor_js)\n    plain_text = models.TextField(\n        blank=True,\n        null=True,\n    )\n\n    class Meta:\n        unique_together = ((\"language_code\", \"attribute_value\"),)\n\n    def __repr__(self) -> str:\n        class_ = type(self)\n        return f\"{class_.__name__}(pk={self.pk!r}, name={self.name!r}, attribute_value_pk={self.attribute_value_id!r})\"\n\n    def __str__(self) -> str:\n        return self.name\n\n    def get_translated_object_id(self):\n        return \"AttributeValue\", self.attribute_value_id\n\n    def get_translated_keys(self):\n        return {\"name\": self.name, \"rich_text\": self.rich_text}\n\n    def get_translation_context(self):\n        context = {}\n        attribute_value = self.attribute_value\n        attribute = attribute_value.attribute\n        context[\"attribute_id\"] = attribute.id\n        if attribute.input_type in AttributeInputType.TYPES_WITH_UNIQUE_VALUES:\n            if attribute.type == AttributeType.PRODUCT_TYPE:\n                if assigned_variant_attribute_value := (\n                    attribute_value.variantvalueassignment.first()\n                ):\n                    if variant := assigned_variant_attribute_value.assignment.variant:\n                        context[\"product_variant_id\"] = variant.id\n                        context[\"product_id\"] = variant.product_id\n                elif assigned_product_attribute_value := (\n                    attribute_value.productvalueassignment.first()\n                ):\n                    if product_id := assigned_product_attribute_value.product_id:\n                        context[\"product_id\"] = product_id\n            elif attribute.type == AttributeType.PAGE_TYPE:\n                if assigned_page_attribute_value := (\n                    attribute_value.pagevalueassignment.first()\n                ):\n                    if page := assigned_page_attribute_value.page:\n                        context[\"page_id\"] = page.id\n                        if page_type_id := page.page_type_id:\n                            context[\"page_type_id\"] = page_type_id\n        return context\n",
      "line": 442
    }
  },
  {
    "http_method": "UNKNOWN",
    "parameters": [],
    "return_type": "unknown",
    "database_operations": [],
    "dafny_function": {
      "name": "delete",
      "preconditions": [
        "requires true"
      ],
      "postconditions": [
        "ensures true"
      ]
    },
    "raw_response": "Based on the provided code context, I analyzed the `delete` function. However, I noticed that the `delete` function is not explicitly defined in the provided code. I assume it's a model method, likely defined in the `Model` class or one of its subclasses.\n\nHere's my analysis:\n\n1. **HTTP method**: The `delete` function likely handles the `DELETE` HTTP method.\n2. **Parameters**: The function probably accepts a single parameter, `self`, which refers to the instance being deleted. There might be additional parameters, but they are not shown in the provided code.\n3. **Return type**: The function likely returns `None` or a boolean indicating whether the deletion was successful.\n4. **Database operations**: The function performs a `delete` operation on the database.\n5. **Business logic**: The function likely implements the logic for deleting a product instance, which might involve cascading deletions of related objects.\n\nHere's a Dafny function specification:\n\n```json\n{\n  \"http_method\": \"DELETE\",\n  \"parameters\": [\"self\"],\n  \"return_type\": \"bool\",\n  \"database_operations\": [\"delete\"],\n  \"dafny_function\": {\n    \"name\": \"delete_product\",\n    \"preconditions\": [\n      \"requires self != null\",\n      \"requires self.id != null\"\n    ],\n    \"postconditions\": [\n      \"ensures !product_exists(self.id)\",\n      \"ensures deleted_product(self)\"\n    ]\n  }\n}\n```\n\nIn this specification:\n\n* `product_exists` and `deleted_product` are assumed to be Dafny functions that interact with the database to check if a product exists or has been deleted, respectively.\n* The `preconditions` ensure that the `self` parameter is not null and has a valid `id`.\n* The `postconditions` ensure that the product no longer exists in the database and that it has been successfully deleted.\n\nNote that this specification is based on assumptions about the `delete` function's behavior, as the actual implementation is not provided. You may need to adjust the specification according to the actual implementation details.",
    "original_api": {
      "name": "delete",
      "file": "/Users/ryanmarr/Documents/saleor/saleor/product/models.py",
      "content": "import datetime\nfrom collections.abc import Iterable\nfrom decimal import Decimal\nfrom typing import Optional\nfrom uuid import uuid4\n\nimport graphene\nfrom django.conf import settings\nfrom django.contrib.postgres.indexes import BTreeIndex, GinIndex\nfrom django.contrib.postgres.search import SearchVectorField\nfrom django.core.validators import MinValueValidator\nfrom django.db import models, transaction\nfrom django.db.models import JSONField, TextField\nfrom django.urls import reverse\nfrom django.utils import timezone\nfrom django_measurement.models import MeasurementField\nfrom measurement.measures import Weight\nfrom mptt.managers import TreeManager\nfrom mptt.models import MPTTModel\nfrom prices import Money\n\nfrom ..channel.models import Channel\nfrom ..core.db.fields import MoneyField, SanitizedJSONField\nfrom ..core.models import (\n    ModelWithExternalReference,\n    ModelWithMetadata,\n    PublishableModel,\n    SortableModel,\n)\nfrom ..core.units import WeightUnits\nfrom ..core.utils import build_absolute_uri\nfrom ..core.utils.editorjs import clean_editor_js\nfrom ..core.utils.translations import Translation, get_translation\nfrom ..core.weight import zero_weight\nfrom ..discount.models import PromotionRule\nfrom ..permission.enums import (\n    DiscountPermissions,\n    OrderPermissions,\n    ProductPermissions,\n    ProductTypePermissions,\n)\nfrom ..seo.models import SeoModel, SeoModelTranslationWithSlug\nfrom ..tax.models import TaxClass\nfrom . import ProductMediaTypes, ProductTypeKind, managers\n\nALL_PRODUCTS_PERMISSIONS = [\n    # List of permissions, where each of them allows viewing all products\n    # (including unpublished).\n    OrderPermissions.MANAGE_ORDERS,\n    DiscountPermissions.MANAGE_DISCOUNTS,\n    ProductPermissions.MANAGE_PRODUCTS,\n]\n\n\nclass Category(ModelWithMetadata, MPTTModel, SeoModel):\n    name = models.CharField(max_length=250)\n    slug = models.SlugField(max_length=255, unique=True, allow_unicode=True)\n    description = SanitizedJSONField(blank=True, null=True, sanitizer=clean_editor_js)\n    description_plaintext = TextField(blank=True)\n    updated_at = models.DateTimeField(auto_now=True, blank=True, null=True)\n    parent = models.ForeignKey(\n        \"self\", null=True, blank=True, related_name=\"children\", on_delete=models.CASCADE\n    )\n    background_image = models.ImageField(\n        upload_to=\"category-backgrounds\", blank=True, null=True\n    )\n    background_image_alt = models.CharField(max_length=128, blank=True)\n\n    objects = models.Manager()\n    tree = TreeManager()  # type: ignore[django-manager-missing]\n\n    class Meta:\n        indexes = [\n            *ModelWithMetadata.Meta.indexes,\n            GinIndex(\n                name=\"category_search_name_slug_gin\",\n                # `opclasses` and `fields` should be the same length\n                fields=[\"name\", \"slug\", \"description_plaintext\"],\n                opclasses=[\"gin_trgm_ops\"] * 3,\n            ),\n            BTreeIndex(fields=[\"updated_at\"], name=\"updated_at_idx\"),\n        ]\n\n    def __str__(self) -> str:\n        return self.name\n\n\nclass CategoryTranslation(SeoModelTranslationWithSlug):\n    category = models.ForeignKey(\n        Category, related_name=\"translations\", on_delete=models.CASCADE\n    )\n    name = models.CharField(max_length=128, blank=True, null=True)\n    description = SanitizedJSONField(blank=True, null=True, sanitizer=clean_editor_js)\n\n    class Meta:\n        constraints = [\n            models.UniqueConstraint(\n                fields=[\"language_code\", \"slug\"],\n                name=\"uniq_lang_slug_categorytransl\",\n            ),\n        ]\n        unique_together = ((\"language_code\", \"category\"),)\n\n    def __str__(self) -> str:\n        return self.name if self.name else str(self.pk)\n\n    def __repr__(self) -> str:\n        class_ = type(self)\n        return f\"{class_.__name__}(pk={self.pk!r}, name={self.name!r}, category_pk={self.category_id!r})\"\n\n    def get_translated_object_id(self):\n        return \"Category\", self.category_id\n\n    def get_translated_keys(self):\n        translated_keys = super().get_translated_keys()\n        translated_keys.update(\n            {\n                \"name\": self.name,\n                \"description\": self.description,\n            }\n        )\n        return translated_keys\n\n\nclass ProductType(ModelWithMetadata):\n    name = models.CharField(max_length=250)\n    slug = models.SlugField(max_length=255, unique=True, allow_unicode=True)\n    kind = models.CharField(max_length=32, choices=ProductTypeKind.CHOICES)\n    has_variants = models.BooleanField(default=True)\n    is_shipping_required = models.BooleanField(default=True)\n    is_digital = models.BooleanField(default=False)\n    weight = MeasurementField(\n        measurement=Weight,\n        unit_choices=WeightUnits.CHOICES,\n        default=zero_weight,\n    )\n    tax_class = models.ForeignKey(\n        TaxClass,\n        related_name=\"product_types\",\n        on_delete=models.SET_NULL,\n        blank=True,\n        null=True,\n    )\n\n    class Meta(ModelWithMetadata.Meta):\n        ordering = (\"slug\",)\n        app_label = \"product\"\n        permissions = (\n            (\n                ProductTypePermissions.MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES.codename,\n                \"Manage product types and attributes.\",\n            ),\n        )\n        indexes = [\n            *ModelWithMetadata.Meta.indexes,\n            GinIndex(\n                name=\"product_type_search_gin\",\n                # `opclasses` and `fields` should be the same length\n                fields=[\"name\", \"slug\"],\n                opclasses=[\"gin_trgm_ops\"] * 2,\n            ),\n        ]\n\n    def __str__(self) -> str:\n        return self.name\n\n    def __repr__(self) -> str:\n        class_ = type(self)\n        return f\"<{class_.__module__}.{class_.__name__}(pk={self.pk!r}, name={self.name!r})>\"\n\n\nclass Product(SeoModel, ModelWithMetadata, ModelWithExternalReference):\n    product_type = models.ForeignKey(\n        ProductType, related_name=\"products\", on_delete=models.CASCADE\n    )\n    name = models.CharField(max_length=250)\n    slug = models.SlugField(max_length=255, unique=True, allow_unicode=True)\n    description = SanitizedJSONField(blank=True, null=True, sanitizer=clean_editor_js)\n    description_plaintext = TextField(blank=True)\n    search_document = models.TextField(blank=True, default=\"\")\n    search_vector = SearchVectorField(blank=True, null=True)\n    search_index_dirty = models.BooleanField(default=False, db_index=True)\n\n    category = models.ForeignKey(\n        Category,\n        related_name=\"products\",\n        on_delete=models.SET_NULL,\n        null=True,\n        blank=True,\n    )\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True, db_index=True)\n    weight = MeasurementField(\n        measurement=Weight,\n        unit_choices=WeightUnits.CHOICES,\n        blank=True,\n        null=True,\n    )\n    default_variant = models.OneToOneField(\n        \"ProductVariant\",\n        blank=True,\n        null=True,\n        on_delete=models.SET_NULL,\n        related_name=\"+\",\n    )\n    rating = models.FloatField(null=True, blank=True)\n    tax_class = models.ForeignKey(\n        TaxClass,\n        related_name=\"products\",\n        blank=True,\n        null=True,\n        on_delete=models.SET_NULL,\n    )\n\n    objects = managers.ProductManager()\n\n    class Meta:\n        app_label = \"product\"\n        ordering = (\"slug\",)\n        permissions = (\n            (ProductPermissions.MANAGE_PRODUCTS.codename, \"Manage products.\"),\n        )\n        indexes = [\n            GinIndex(\n                name=\"product_search_gin\",\n                fields=[\"search_document\"],\n                opclasses=[\"gin_trgm_ops\"],\n            ),\n            GinIndex(\n                name=\"product_tsearch\",\n                fields=[\"search_vector\"],\n            ),\n            GinIndex(\n                name=\"product_gin\",\n                fields=[\"name\", \"slug\"],\n                opclasses=[\"gin_trgm_ops\"] * 2,\n            ),\n            models.Index(\n                fields=[\"category_id\", \"slug\"],\n            ),\n        ]\n        indexes.extend(ModelWithMetadata.Meta.indexes)\n\n    def __iter__(self):\n        if not hasattr(self, \"__variants\"):\n            setattr(self, \"__variants\", self.variants.all())\n        return iter(getattr(self, \"__variants\"))\n\n    def __repr__(self) -> str:\n        class_ = type(self)\n        return f\"<{class_.__module__}.{class_.__name__}(pk={self.pk!r}, name={self.name!r})>\"\n\n    def __str__(self) -> str:\n        return self.name\n\n    def get_first_image(self):\n        all_media = self.media.all()\n        images = [media for media in all_media if media.type == ProductMediaTypes.IMAGE]\n        return images[0] if images else None\n\n    @staticmethod\n    def sort_by_attribute_fields() -> list:\n        return [\"concatenated_values_order\", \"concatenated_values\", \"name\"]\n\n\nclass ProductTranslation(SeoModelTranslationWithSlug):\n    product = models.ForeignKey(\n        Product, related_name=\"translations\", on_delete=models.CASCADE\n    )\n    name = models.CharField(max_length=250, blank=True, null=True)\n    description = SanitizedJSONField(blank=True, null=True, sanitizer=clean_editor_js)\n\n    class Meta:\n        constraints = [\n            models.UniqueConstraint(\n                fields=[\"language_code\", \"slug\"],\n                name=\"uniq_lang_slug_producttransl\",\n            ),\n        ]\n        unique_together = ((\"language_code\", \"product\"),)\n\n    def __str__(self) -> str:\n        return self.name if self.name else str(self.pk)\n\n    def __repr__(self) -> str:\n        class_ = type(self)\n        return f\"{class_.__name__}(pk={self.pk!r}, name={self.name!r}, product_pk={self.product_id!r})\"\n\n    def get_translated_object_id(self):\n        return \"Product\", self.product_id\n\n    def get_translated_keys(self):\n        translated_keys = super().get_translated_keys()\n        translated_keys.update(\n            {\n                \"name\": self.name,\n                \"description\": self.description,\n            }\n        )\n        return translated_keys\n\n\nclass ProductChannelListing(PublishableModel):\n    product = models.ForeignKey(\n        Product,\n        null=False,\n        blank=False,\n        related_name=\"channel_listings\",\n        on_delete=models.CASCADE,\n    )\n    channel = models.ForeignKey(\n        Channel,\n        null=False,\n        blank=False,\n        related_name=\"product_listings\",\n        on_delete=models.CASCADE,\n    )\n    visible_in_listings = models.BooleanField(default=False)\n    available_for_purchase_at = models.DateTimeField(blank=True, null=True)\n    currency = models.CharField(max_length=settings.DEFAULT_CURRENCY_CODE_LENGTH)\n    discounted_price_amount = models.DecimalField(\n        max_digits=settings.DEFAULT_MAX_DIGITS,\n        decimal_places=settings.DEFAULT_DECIMAL_PLACES,\n        blank=True,\n        null=True,\n    )\n    discounted_price = MoneyField(\n        amount_field=\"discounted_price_amount\", currency_field=\"currency\"\n    )\n    discounted_price_dirty = models.BooleanField(default=False)\n\n    class Meta:\n        unique_together = [[\"product\", \"channel\"]]\n        ordering = (\"pk\",)\n        indexes = [\n            models.Index(fields=[\"published_at\"]),\n            BTreeIndex(fields=[\"discounted_price_amount\"]),\n        ]\n\n    def is_available_for_purchase(self):\n        return (\n            self.available_for_purchase_at is not None\n            and datetime.datetime.now(tz=datetime.UTC) >= self.available_for_purchase_at\n        )\n\n\nclass ProductVariant(SortableModel, ModelWithMetadata, ModelWithExternalReference):\n    sku = models.CharField(max_length=255, unique=True, null=True, blank=True)\n    name = models.CharField(max_length=255, blank=True)\n    product = models.ForeignKey(\n        Product, related_name=\"variants\", on_delete=models.CASCADE\n    )\n    media = models.ManyToManyField(\n        \"product.ProductMedia\", through=\"product.VariantMedia\"\n    )\n    track_inventory = models.BooleanField(default=True)\n    is_preorder = models.BooleanField(default=False)\n    preorder_end_date = models.DateTimeField(null=True, blank=True)\n    preorder_global_threshold = models.IntegerField(blank=True, null=True)\n    quantity_limit_per_customer = models.IntegerField(\n        blank=True, null=True, validators=[MinValueValidator(1)]\n    )\n    created_at = models.DateTimeField(auto_now_add=True, db_index=True)\n    updated_at = models.DateTimeField(auto_now=True, db_index=True)\n\n    weight = MeasurementField(\n        measurement=Weight,\n        unit_choices=WeightUnits.CHOICES,\n        blank=True,\n        null=True,\n    )\n\n    objects = managers.ProductVariantManager()\n\n    class Meta(ModelWithMetadata.Meta):\n        ordering = (\"sort_order\", \"sku\")\n        app_label = \"product\"\n        indexes = [\n            *ModelWithMetadata.Meta.indexes,\n            GinIndex(\n                name=\"variant_gin\",\n                fields=[\"name\", \"sku\"],\n                opclasses=[\"gin_trgm_ops\"] * 2,\n            ),\n        ]\n\n    def __str__(self) -> str:\n        return self.name or self.sku or f\"ID:{self.pk}\"\n\n    def get_global_id(self):\n        return graphene.Node.to_global_id(\"ProductVariant\", self.id)\n\n    def get_base_price(\n        self,\n        channel_listing: \"ProductVariantChannelListing\",\n        price_override: Optional[\"Decimal\"] = None,\n    ) -> \"Money\":\n        \"\"\"Return the base variant price before applying the promotion discounts.\"\"\"\n        return (\n            channel_listing.price\n            if price_override is None\n            else Money(price_override, channel_listing.currency)\n        )\n\n    def get_price(\n        self,\n        channel_listing: \"ProductVariantChannelListing\",\n        price_override: Optional[\"Decimal\"] = None,\n        promotion_rules: Iterable[\"PromotionRule\"] | None = None,\n    ) -> \"Money\":\n        \"\"\"Return the variant discounted price with applied promotions.\n\n        If a custom price is provided, return the price with applied discounts from\n        valid promotion rules for this variant.\n        \"\"\"\n        from ..discount.utils.promotion import calculate_discounted_price_for_rules\n\n        if price_override is None:\n            return channel_listing.discounted_price or channel_listing.price\n        price: Money = self.get_base_price(channel_listing, price_override)\n        rules = promotion_rules or []\n        return calculate_discounted_price_for_rules(\n            price=price, rules=rules, currency=channel_listing.currency\n        )\n\n    def get_prior_price_amount(\n        self,\n        channel_listing: Optional[\"ProductVariantChannelListing\"],\n    ) -> Decimal | None:\n        if channel_listing is None or channel_listing.prior_price is None:\n            return None\n\n        return channel_listing.prior_price.amount\n\n    def get_weight(self):\n        return self.weight or self.product.weight or self.product.product_type.weight\n\n    def is_shipping_required(self) -> bool:\n        return self.product.product_type.is_shipping_required\n\n    def is_gift_card(self) -> bool:\n        return self.product.product_type.kind == ProductTypeKind.GIFT_CARD\n\n    def is_digital(self) -> bool:\n        is_digital = self.product.product_type.is_digital\n        return not self.is_shipping_required() and is_digital\n\n    def display_product(self, translated: bool = False) -> str:\n        if translated:\n            product = get_translation(self.product).name or \"\"\n            variant_display = get_translation(self).name\n        else:\n            variant_display = str(self)\n            product = self.product\n        product_display = (\n            f\"{product} ({variant_display})\" if variant_display else str(product)\n        )\n        return product_display\n\n    def get_ordering_queryset(self):\n        return self.product.variants.all()\n\n    def is_preorder_active(self):\n        return self.is_preorder and (\n            self.preorder_end_date is None or timezone.now() <= self.preorder_end_date\n        )\n\n\nclass ProductVariantTranslation(Translation):\n    product_variant = models.ForeignKey(\n        ProductVariant, related_name=\"translations\", on_delete=models.CASCADE\n    )\n    name = models.CharField(max_length=255, blank=True)\n\n    class Meta:\n        unique_together = ((\"language_code\", \"product_variant\"),)\n\n    def __repr__(self):\n        class_ = type(self)\n        return f\"{class_.__name__}(pk={self.pk!r}, name={self.name!r}, variant_pk={self.product_variant_id!r})\"\n\n    def __str__(self):\n        return self.name or str(self.product_variant)\n\n    def get_translated_object_id(self):\n        return \"ProductVariant\", self.product_variant_id\n\n    def get_translated_keys(self):\n        return {\"name\": self.name}\n\n\nclass ProductVariantChannelListing(models.Model):\n    variant = models.ForeignKey(\n        ProductVariant,\n        null=False,\n        blank=False,\n        related_name=\"channel_listings\",\n        on_delete=models.CASCADE,\n    )\n    channel = models.ForeignKey(\n        Channel,\n        null=False,\n        blank=False,\n        related_name=\"variant_listings\",\n        on_delete=models.CASCADE,\n    )\n    currency = models.CharField(max_length=settings.DEFAULT_CURRENCY_CODE_LENGTH)\n    price_amount = models.DecimalField(\n        max_digits=settings.DEFAULT_MAX_DIGITS,\n        decimal_places=settings.DEFAULT_DECIMAL_PLACES,\n        blank=True,\n        null=True,\n    )\n    price = MoneyField(amount_field=\"price_amount\", currency_field=\"currency\")\n\n    cost_price_amount = models.DecimalField(\n        max_digits=settings.DEFAULT_MAX_DIGITS,\n        decimal_places=settings.DEFAULT_DECIMAL_PLACES,\n        blank=True,\n        null=True,\n    )\n    cost_price = MoneyField(amount_field=\"cost_price_amount\", currency_field=\"currency\")\n\n    prior_price_amount = models.DecimalField(\n        max_digits=settings.DEFAULT_MAX_DIGITS,\n        decimal_places=settings.DEFAULT_DECIMAL_PLACES,\n        blank=True,\n        null=True,\n    )\n    prior_price = MoneyField(\n        amount_field=\"prior_price_amount\", currency_field=\"currency\"\n    )\n\n    discounted_price_amount = models.DecimalField(\n        max_digits=settings.DEFAULT_MAX_DIGITS,\n        decimal_places=settings.DEFAULT_DECIMAL_PLACES,\n        blank=True,\n        null=True,\n    )\n    discounted_price = MoneyField(\n        amount_field=\"discounted_price_amount\", currency_field=\"currency\"\n    )\n    promotion_rules = models.ManyToManyField(\n        PromotionRule,\n        help_text=(\"Promotion rules that were included in the discounted price.\"),\n        through=\"product.VariantChannelListingPromotionRule\",\n        blank=True,\n    )\n\n    preorder_quantity_threshold = models.IntegerField(blank=True, null=True)\n\n    objects = managers.ProductVariantChannelListingManager()\n\n    class Meta:\n        unique_together = [[\"variant\", \"channel\"]]\n        ordering = (\"pk\",)\n        indexes = [\n            GinIndex(fields=[\"price_amount\", \"channel_id\"]),\n        ]\n\n\nclass VariantChannelListingPromotionRule(models.Model):\n    variant_channel_listing = models.ForeignKey(\n        ProductVariantChannelListing,\n        related_name=\"variantlistingpromotionrule\",\n        on_delete=models.CASCADE,\n    )\n    promotion_rule = models.ForeignKey(\n        PromotionRule,\n        related_name=\"variantlistingpromotionrule\",\n        on_delete=models.CASCADE,\n    )\n    discount_amount = models.DecimalField(\n        max_digits=settings.DEFAULT_MAX_DIGITS,\n        decimal_places=settings.DEFAULT_DECIMAL_PLACES,\n        default=Decimal(\"0.0\"),\n    )\n    discount = MoneyField(amount_field=\"discount_amount\", currency_field=\"currency\")\n    currency = models.CharField(\n        max_length=settings.DEFAULT_CURRENCY_CODE_LENGTH,\n    )\n\n    class Meta:\n        unique_together = [[\"variant_channel_listing\", \"promotion_rule\"]]\n\n\nclass DigitalContent(ModelWithMetadata):\n    FILE = \"file\"\n    TYPE_CHOICES = ((FILE, \"digital_product\"),)\n    use_default_settings = models.BooleanField(default=True)\n    automatic_fulfillment = models.BooleanField(default=False)\n    content_type = models.CharField(max_length=128, default=FILE, choices=TYPE_CHOICES)\n    product_variant = models.OneToOneField(\n        ProductVariant, related_name=\"digital_content\", on_delete=models.CASCADE\n    )\n    content_file = models.FileField(upload_to=\"digital_contents\", blank=True)\n    max_downloads = models.IntegerField(blank=True, null=True)\n    url_valid_days = models.IntegerField(blank=True, null=True)\n\n    def create_new_url(self) -> \"DigitalContentUrl\":\n        return self.urls.create()\n\n\nclass DigitalContentUrl(models.Model):\n    token = models.UUIDField(editable=False, unique=True)\n    content = models.ForeignKey(\n        DigitalContent, related_name=\"urls\", on_delete=models.CASCADE\n    )\n    created_at = models.DateTimeField(auto_now_add=True)\n    download_num = models.IntegerField(default=0)\n    line = models.OneToOneField(\n        \"order.OrderLine\",\n        related_name=\"digital_content_url\",\n        blank=True,\n        null=True,\n        on_delete=models.CASCADE,\n    )\n\n    def save(\n        self, force_insert=False, force_update=False, using=None, update_fields=None\n    ):\n        if not self.token:\n            self.token = str(uuid4()).replace(\"-\", \"\")\n        super().save(\n            force_insert=force_insert,\n            force_update=force_update,\n            using=using,\n            update_fields=update_fields,\n        )\n\n    def get_absolute_url(self) -> str | None:\n        url = reverse(\"digital-product\", kwargs={\"token\": str(self.token)})\n        return build_absolute_uri(url)\n\n\nclass ProductMedia(SortableModel, ModelWithMetadata):\n    product = models.ForeignKey(\n        Product,\n        related_name=\"media\",\n        on_delete=models.CASCADE,\n        # DEPRECATED\n        null=True,\n        blank=True,\n    )\n    image = models.ImageField(upload_to=\"products\", blank=True, null=True)\n    alt = models.CharField(max_length=250, blank=True)\n    type = models.CharField(\n        max_length=32,\n        choices=ProductMediaTypes.CHOICES,\n        default=ProductMediaTypes.IMAGE,\n    )\n    external_url = models.CharField(max_length=256, blank=True, null=True)\n    oembed_data = JSONField(blank=True, default=dict)\n    # DEPRECATED\n    to_remove = models.BooleanField(default=False)\n\n    class Meta(ModelWithMetadata.Meta):\n        ordering = (\"sort_order\", \"pk\")\n        app_label = \"product\"\n\n    def get_ordering_queryset(self):\n        if not self.product:\n            return ProductMedia.objects.none()\n        return self.product.media.all()\n\n    @transaction.atomic\n    def delete(self, *args, **kwargs):\n        super(SortableModel, self).delete(*args, **kwargs)\n\n\nclass VariantMedia(models.Model):\n    variant = models.ForeignKey(\n        \"ProductVariant\", related_name=\"variant_media\", on_delete=models.CASCADE\n    )\n    media = models.ForeignKey(\n        ProductMedia, related_name=\"variant_media\", on_delete=models.CASCADE\n    )\n\n    class Meta:\n        unique_together = (\"variant\", \"media\")\n\n\nclass CollectionProduct(SortableModel):\n    collection = models.ForeignKey(\n        \"Collection\", related_name=\"collectionproduct\", on_delete=models.CASCADE\n    )\n    product = models.ForeignKey(\n        Product, related_name=\"collectionproduct\", on_delete=models.CASCADE\n    )\n\n    class Meta:\n        unique_together = ((\"collection\", \"product\"),)\n\n    def get_ordering_queryset(self):\n        return self.product.collectionproduct.all()\n\n\nclass Collection(SeoModel, ModelWithMetadata):\n    name = models.CharField(max_length=250)\n    slug = models.SlugField(max_length=255, unique=True, allow_unicode=True)\n    products = models.ManyToManyField(\n        Product,\n        blank=True,\n        related_name=\"collections\",\n        through=CollectionProduct,\n        through_fields=(\"collection\", \"product\"),\n    )\n    background_image = models.ImageField(\n        upload_to=\"collection-backgrounds\", blank=True, null=True\n    )\n    background_image_alt = models.CharField(max_length=128, blank=True)\n\n    description = SanitizedJSONField(blank=True, null=True, sanitizer=clean_editor_js)\n\n    objects = managers.CollectionManager()\n\n    class Meta(ModelWithMetadata.Meta):\n        ordering = (\"slug\",)\n        indexes = [\n            *ModelWithMetadata.Meta.indexes,\n            GinIndex(\n                name=\"collection_search_gin\",\n                # `opclasses` and `fields` should be the same length\n                fields=[\"name\", \"slug\"],\n                opclasses=[\"gin_trgm_ops\"] * 2,\n            ),\n        ]\n\n    def __str__(self) -> str:\n        return self.name\n\n\nclass CollectionChannelListing(PublishableModel):\n    collection = models.ForeignKey(\n        Collection,\n        null=False,\n        blank=False,\n        related_name=\"channel_listings\",\n        on_delete=models.CASCADE,\n    )\n    channel = models.ForeignKey(\n        Channel,\n        null=False,\n        blank=False,\n        related_name=\"collection_listings\",\n        on_delete=models.CASCADE,\n    )\n\n    class Meta:\n        unique_together = [[\"collection\", \"channel\"]]\n        ordering = (\"pk\",)\n\n\nclass CollectionTranslation(SeoModelTranslationWithSlug):\n    collection = models.ForeignKey(\n        Collection, related_name=\"translations\", on_delete=models.CASCADE\n    )\n    name = models.CharField(max_length=128, blank=True, null=True)\n    description = SanitizedJSONField(blank=True, null=True, sanitizer=clean_editor_js)\n\n    class Meta:\n        constraints = [\n            models.UniqueConstraint(\n                fields=[\"language_code\", \"slug\"],\n                name=\"uniq_lang_slug_collectiontransl\",\n            ),\n        ]\n        unique_together = ((\"language_code\", \"collection\"),)\n\n    def __repr__(self):\n        class_ = type(self)\n        return f\"{class_.__name__}(pk={self.pk!r}, name={self.name!r}, collection_pk={self.collection_id!r})\"\n\n    def __str__(self) -> str:\n        return self.name if self.name else str(self.pk)\n\n    def get_translated_object_id(self):\n        return \"Collection\", self.collection_id\n\n    def get_translated_keys(self):\n        translated_keys = super().get_translated_keys()\n        translated_keys.update(\n            {\n                \"name\": self.name,\n                \"description\": self.description,\n            }\n        )\n        return translated_keys\n",
      "line": 667
    }
  },
  {
    "http_method": "UNKNOWN",
    "parameters": [],
    "return_type": "unknown",
    "database_operations": [],
    "dafny_function": {
      "name": "post",
      "preconditions": [
        "requires true"
      ],
      "postconditions": [
        "ensures true"
      ]
    },
    "raw_response": "## Analysis of the Django REST API Function\n\n### 1. HTTP Method\nThe API function handles the `POST` HTTP method.\n\n### 2. Parameters\nThe function accepts the following parameters:\n- `user`: an optional parameter representing the user making the request\n- `app`: an optional parameter representing the app making the request\n- `api_path`: an optional parameter representing the API path\n- The request body, which is expected to be in JSON format\n\n### 3. Return Type\nThe return type of the function is not explicitly defined, but based on the context, it appears to return a JSON response.\n\n### 4. Database Operations\nThe function performs the following database operations:\n- Reads: It retrieves the user and app objects from the database.\n- Writes: It creates a new token for the app if one does not exist.\n\n### 5. Business Logic\nThe function implements the following business logic:\n- It sets up an API client with the provided user, app, and API path.\n- It ensures that an access token is generated for the user if one does not exist.\n- It sets the HTTP authorization header with the access token or app token.\n\n## Dafny Function Specification\n\nHere is the Dafny function specification:\n\n```json\n{\n  \"http_method\": \"POST\",\n  \"parameters\": [\"user\", \"app\", \"api_path\"],\n  \"return_type\": \"object\",\n  \"database_operations\": [\"read\", \"write\"],\n  \"dafny_function\": {\n    \"name\": \"PostApiRequest\",\n    \"preconditions\": [\n      \"requires user == null || user.Valid\",\n      \"requires app == null || app.Valid\",\n      \"requires api_path == null || api_path.ValidString\"\n    ],\n    \"postconditions\": [\n      \"ensures result != null\",\n      \"ensures result.Authorization == \\\"JWT <token>\\\" || result.Authorization == \\\"Bearer <app_token>\\\"\",\n      \"ensures result.api_path == api_path || result.api_path == API_PATH\"\n    ]\n  }\n}\n```\n\nNote that in the Dafny specification, we assume that `user`, `app`, and `api_path` are already defined types, and that `Valid` and `ValidString` are properties or functions that check the validity of these types.\n\nAlso, in the postconditions, `<token>` and `<app_token>` represent the generated access token and app token, respectively.\n\n## Dafny Code\n\nHere is an example of what the Dafny code might look like:\n```dafny\nfunction PostApiRequest(user: User, app: App, api_path: string) returns (result: ApiResponse)\n  requires user == null || user.Valid\n  requires app == null || app.Valid\n  requires api_path == null || api_path.ValidString\n  ensures result != null\n  ensures result.Authorization == \"JWT <token>\" || result.Authorization == \"Bearer <app_token>\"\n  ensures result.api_path == api_path || result.api_path == API_PATH\n{\n  // implementation\n}\n```\nNote that this is just an example, and the actual Dafny code would depend on the specific requirements and implementation details of the API function.",
    "original_api": {
      "name": "post",
      "file": "/Users/ryanmarr/Documents/saleor/saleor/graphql/tests/fixtures.py",
      "content": "import json\nimport logging\nfrom unittest import mock\nfrom unittest.mock import Mock\n\nimport graphene\nimport pytest\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.test import TestCase\nfrom django.test.client import MULTIPART_CONTENT, Client\nfrom django.urls import reverse\nfrom django.utils.functional import SimpleLazyObject\n\nfrom ...account.models import User\nfrom ...core.jwt import create_access_token\nfrom ...plugins.manager import get_plugins_manager\nfrom ..utils import handled_errors_logger, unhandled_errors_logger\nfrom .utils import assert_no_permission\n\nAPI_PATH = reverse(\"api\")\n\n\nclass BaseApiClient(Client):\n    \"\"\"GraphQL API client.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        user = kwargs.pop(\"user\", None)\n        app = kwargs.pop(\"app\", None)\n        api_path = kwargs.pop(\"api_path\", None)\n        self._user = None\n        self.token = None\n        self.user = user\n        self.app_token = None\n        self.app = app\n        if app:\n            _, auth_token = app.tokens.create(name=\"Default\")\n            self.app_token = auth_token\n        self.api_path = API_PATH\n        if api_path:\n            self.api_path = api_path\n        super().__init__(*args, **kwargs)\n\n    def _base_environ(self, **request):\n        environ = super()._base_environ(**request)\n        self.ensure_access_token()\n        if self.token:\n            environ[\"HTTP_AUTHORIZATION\"] = f\"JWT {self.token}\"\n        elif self.app_token:\n            environ[\"HTTP_AUTHORIZATION\"] = f\"Bearer {self.app_token}\"\n        return environ\n\n    def regenerate_access_token(self):\n        if self.user and self.token:\n            self.token = create_access_token(self.user)\n        else:\n            self.token = None\n\n    def ensure_access_token(self):\n        if self.user and not self.token:\n            self.token = create_access_token(self.user)\n\n    @property\n    def user(self):\n        return self._user\n\n    @user.setter\n    def user(self, user):\n        self._user = user\n        self.token = None\n\n    def post(self, data=None, **kwargs):\n        \"\"\"Send a POST request.\n\n        This wrapper sets the `application/json` content type which is\n        more suitable for standard GraphQL requests and doesn't mismatch with\n        handling multipart requests in Graphene.\n        \"\"\"\n        if data:\n            data = json.dumps(data, cls=DjangoJSONEncoder)\n        kwargs[\"content_type\"] = \"application/json\"\n        return super().post(self.api_path, data, **kwargs)\n\n\nclass ApiClient(BaseApiClient):\n    def post_graphql(\n        self,\n        query,\n        variables=None,\n        # @deprecated - do not use it, because it makes implicit permissions check\n        # Use explicit permissions assertions\n        permissions=None,\n        check_no_permissions=True,\n        **kwargs,\n    ):\n        \"\"\"Dedicated helper for posting GraphQL queries.\n\n        Sets the `application/json` content type and json.dumps the variables\n        if present.\n        \"\"\"\n        data = {\"query\": query}\n        if variables is not None:\n            data[\"variables\"] = variables\n        if data:\n            data = json.dumps(data, cls=DjangoJSONEncoder)\n        kwargs[\"content_type\"] = \"application/json\"\n\n        if permissions:\n            if check_no_permissions:\n                with mock.patch(\"saleor.graphql.utils.handled_errors_logger\"):\n                    response = super(Client, self).post(self.api_path, data, **kwargs)\n                assert_no_permission(response)\n            if self.app:\n                self.app.permissions.add(*permissions)\n            else:\n                self.user.user_permissions.add(*permissions)\n        with TestCase.captureOnCommitCallbacks(execute=True):\n            result = super(Client, self).post(self.api_path, data, **kwargs)\n        return result\n\n    def post_multipart(self, *args, permissions=None, **kwargs):\n        \"\"\"Send a multipart POST request.\n\n        This is used to send multipart requests to GraphQL API when e.g.\n        uploading files.\n        \"\"\"\n        kwargs[\"content_type\"] = MULTIPART_CONTENT\n\n        if permissions:\n            response = super(Client, self).post(self.api_path, *args, **kwargs)\n            assert_no_permission(response)\n            self.user.user_permissions.add(*permissions)\n        with TestCase.captureOnCommitCallbacks(execute=True):\n            result = super(Client, self).post(self.api_path, *args, **kwargs)\n        return result\n\n\n@pytest.fixture\ndef app_api_client(app):\n    return ApiClient(app=app)\n\n\n@pytest.fixture\ndef staff_api_client(staff_user):\n    return ApiClient(user=staff_user)\n\n\n@pytest.fixture\ndef superuser_api_client(superuser):\n    return ApiClient(user=superuser)\n\n\n@pytest.fixture\ndef user_api_client(customer_user):\n    return ApiClient(user=customer_user)\n\n\n@pytest.fixture\ndef user2_api_client(customer_user2):\n    return ApiClient(user=customer_user2)\n\n\n@pytest.fixture\ndef api_client():\n    return ApiClient(user=None)\n\n\n@pytest.fixture\ndef schema_context():\n    params = {\n        \"user\": SimpleLazyObject(lambda: None),\n        \"app\": SimpleLazyObject(lambda: None),\n        \"plugins\": get_plugins_manager(allow_replica=False),\n        \"auth_token\": \"\",\n    }\n    return graphene.types.Context(**params)\n\n\n@pytest.fixture\ndef info(schema_context):\n    return Mock(context=schema_context)\n\n\n@pytest.fixture\ndef anonymous_plugins():\n    return get_plugins_manager(allow_replica=False)\n\n\nclass LoggingHandler(logging.Handler):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.messages = []\n\n    def emit(self, record: logging.LogRecord):\n        exc_type, exc_value, _tb = record.exc_info\n        self.messages.append(\n            f\"{record.name}[{record.levelname.upper()}].{exc_type.__name__}\"\n        )\n\n\n@pytest.fixture\ndef graphql_log_handler():\n    log_handler = LoggingHandler()\n\n    unhandled_errors_logger.addHandler(log_handler)\n    handled_errors_logger.addHandler(log_handler)\n\n    return log_handler\n\n\n@pytest.fixture\ndef superuser(db):\n    superuser = User.objects.create_user(\n        \"superuser@example.com\",\n        \"pass\",\n        is_staff=True,\n        is_active=True,\n        is_superuser=True,\n    )\n    return superuser\n\n\n@pytest.fixture\ndef user_list():\n    users = User.objects.bulk_create(\n        [\n            User(email=\"user-2@example.com\"),\n            User(email=\"user-1@example.com\"),\n            User(email=\"staff-1@example.com\", is_staff=True),\n            User(email=\"staff-2@example.com\", is_staff=True),\n        ]\n    )\n    return users\n\n\n@pytest.fixture\ndef user_list_not_active(user_list):\n    users = User.objects.filter(pk__in=[user.pk for user in user_list])\n    users.update(is_active=False)\n    return users\n",
      "line": 71
    }
  },
  {
    "http_method": "UNKNOWN",
    "parameters": [],
    "return_type": "unknown",
    "database_operations": [],
    "dafny_function": {
      "name": "delete",
      "preconditions": [
        "requires true"
      ],
      "postconditions": [
        "ensures true"
      ]
    },
    "raw_response": "Based on the provided code, I analyzed the `delete` function in the `Warehouse` model. Here are the results:\n\n**1. HTTP method:** The `delete` function is likely used in a DELETE request, as it seems to be a model method that performs deletion.\n\n**2. Parameters:** The function does not explicitly accept any parameters. However, it might be called with an instance of the `Warehouse` model.\n\n**3. Return type:** The function does not return any value (i.e., it returns `None`).\n\n**4. Database operations:** The function performs a `delete` operation on the database.\n\n**5. Business logic:** The function likely implements the deletion of a warehouse instance, which might involve cascading deletions of related objects.\n\nHere is the Dafny function specification:\n\n```json\n{\n  \"http_method\": \"DELETE\",\n  \"parameters\": [\"warehouse\"],\n  \"return_type\": \"void\",\n  \"database_operations\": [\"delete\"],\n  \"dafny_function\": {\n    \"name\": \"DeleteWarehouse\",\n    \"preconditions\": [\n      \"requires warehouse != null\",\n      \"requires warehouse instanceof Warehouse\"\n    ],\n    \"postconditions\": [\n      \"ensures !Warehouse.Exists(warehouse.id)\",\n      \"ensures forall w :: Warehouse | w.id != warehouse.id ==> w == old(w)\"\n    ]\n  }\n}\n```\n\nIn this specification:\n\n* `DeleteWarehouse` is the name of the Dafny function.\n* The `preconditions` clause specifies that the `warehouse` parameter must not be null and must be an instance of `Warehouse`.\n* The `postconditions` clause ensures that:\n\t+ The warehouse with the given ID no longer exists in the database.\n\t+ All other warehouses in the database remain unchanged.\n\nNote that this specification assumes that the `Warehouse` type and its methods (e.g., `Exists`) are already defined in Dafny. Additionally, the `old` function is used to refer to the state of the database before the deletion operation.",
    "original_api": {
      "name": "delete",
      "file": "/Users/ryanmarr/Documents/saleor/saleor/warehouse/models.py",
      "content": "import itertools\nimport uuid\nfrom collections import defaultdict\nfrom collections.abc import Iterable\nfrom typing import TYPE_CHECKING, TypedDict, TypeVar, cast\n\nfrom django.contrib.postgres.indexes import BTreeIndex\nfrom django.db import models\nfrom django.db.models import Exists, F, OuterRef, Prefetch, Q, Sum\nfrom django.db.models.expressions import Subquery\nfrom django.db.models.functions import Coalesce\nfrom django.db.models.query import QuerySet\nfrom django.utils import timezone\nfrom django_stubs_ext import WithAnnotations\n\nfrom ..account.models import Address\nfrom ..channel.models import Channel\nfrom ..checkout.models import CheckoutLine\nfrom ..core.models import ModelWithExternalReference, ModelWithMetadata, SortableModel\nfrom ..order.models import OrderLine\nfrom ..product.models import Product, ProductVariant, ProductVariantChannelListing\nfrom ..shipping.models import ShippingZone\nfrom . import WarehouseClickAndCollectOption\n\nif TYPE_CHECKING:\n    # https://github.com/typeddjango/django-stubs/issues/719\n\n    class WithAvailableQuantity(TypedDict):\n        available_quantity: int\n\n    class WithTotalAvailableQuantity(TypedDict):\n        available_quantity: int\n\n    StockWithAvailableQuantity = WithAnnotations[\"Stock\", WithAvailableQuantity]\n    StockWithTotalAvailableQuantity = WithAnnotations[\n        \"Stock\", WithTotalAvailableQuantity\n    ]\nelse:\n    StockWithAvailableQuantity = \"Stock\"\n    StockWithTotalAvailableQuantity = \"Stock\"\n\n\nclass WarehouseQueryset(models.QuerySet[\"Warehouse\"]):\n    def for_channel(self, channel_id: int):\n        WarehouseChannel = Channel.warehouses.through\n        return self.filter(\n            Exists(\n                WarehouseChannel.objects.filter(\n                    channel_id=channel_id, warehouse_id=OuterRef(\"id\")\n                )\n            )\n        ).order_by(\"pk\")\n\n    def for_channel_with_active_shipping_zone_or_cc(self, channel_slug: str):\n        WarehouseChannel = Channel.warehouses.through\n        ShippingZoneChannel = Channel.shipping_zones.through\n        WarehouseShippingZone = ShippingZone.warehouses.through\n\n        channel = Channel.objects.filter(slug=channel_slug).values(\"pk\")\n        warehouse_channels = WarehouseChannel.objects.filter(\n            Exists(channel.filter(pk=OuterRef(\"channel_id\")))\n        ).values(\"warehouse_id\")\n\n        shipping_zone_channels = ShippingZoneChannel.objects.filter(\n            Exists(channel.filter(pk=OuterRef(\"channel_id\")))\n        ).values(\"shippingzone_id\")\n\n        warehouse_shipping_zones = WarehouseShippingZone.objects.filter(\n            Exists(warehouse_channels.filter(warehouse_id=OuterRef(\"warehouse_id\"))),\n            Exists(\n                shipping_zone_channels.filter(\n                    shippingzone_id=OuterRef(\"shippingzone_id\")\n                )\n            ),\n        ).values(\"warehouse_id\")\n        return self.filter(\n            Q(\n                Exists(warehouse_channels.filter(warehouse_id=OuterRef(\"id\"))),\n                click_and_collect_option__in=[\n                    WarehouseClickAndCollectOption.LOCAL_STOCK,\n                    WarehouseClickAndCollectOption.ALL_WAREHOUSES,\n                ],\n            )\n            | Q(Exists(warehouse_shipping_zones.filter(warehouse_id=OuterRef(\"id\"))))\n        )\n\n    def for_country_and_channel(self, country: str, channel_id: int):\n        ShippingZoneChannel = Channel.shipping_zones.through\n        WarehouseShippingZone = ShippingZone.warehouses.through\n        WarehouseChannel = Channel.warehouses.through\n\n        shipping_zones = ShippingZone.objects.filter(\n            countries__contains=country\n        ).values(\"pk\")\n        shipping_zone_channels = ShippingZoneChannel.objects.filter(\n            Exists(shipping_zones.filter(pk=OuterRef(\"shippingzone_id\"))),\n            channel_id=channel_id,\n        )\n\n        warehouse_shipping_zones = WarehouseShippingZone.objects.filter(\n            Exists(\n                shipping_zone_channels.filter(\n                    shippingzone_id=OuterRef(\"shippingzone_id\")\n                )\n            ),\n            Exists(\n                WarehouseChannel.objects.filter(\n                    channel_id=channel_id, warehouse_id=OuterRef(\"warehouse_id\")\n                )\n            ),\n        ).values(\"warehouse_id\")\n        return self.filter(\n            Exists(warehouse_shipping_zones.filter(warehouse_id=OuterRef(\"pk\")))\n        ).order_by(\"pk\")\n\n    def applicable_for_click_and_collect_no_quantity_check(\n        self,\n        lines_qs: QuerySet[CheckoutLine] | QuerySet[OrderLine],\n        channel_id: int,\n    ):\n        \"\"\"Return Warehouses which support click and collect.\n\n        Note this method does not check stocks quantity for given `CheckoutLine`s.\n        This method should be used only if stocks quantity will be checked in further\n        validation steps, for instance in checkout completion.\n        \"\"\"\n        if all(\n            line.variant.is_preorder_active() if line.variant else False\n            for line in lines_qs.select_related(\"variant\").only(\"variant_id\")\n        ):\n            return self._for_channel_click_and_collect(channel_id)\n\n        warehouses_for_channel = self.for_channel(channel_id)\n        stocks_qs = Stock.objects.filter(\n            product_variant_id__in=lines_qs.values(\"variant_id\"),\n        ).order_by()\n        warehouses_with_stock_available = (\n            warehouses_for_channel._cc_points_for_stocks(stocks_qs)\n            .order_by()\n            .only(\"id\")\n        )\n\n        number_of_variants = len(\n            set(lines_qs.order_by().values_list(\"variant_id\", flat=True))\n        )\n        # Find out warehouses that can cover the order from a single warehouse\n        warehouse_ids = []\n        for warehouse in warehouses_with_stock_available:\n            # the `warehouses_with_stock_available` contains prefetched stocks\n            # that contains only stocks for the given variants (from the `stocks_qs`)\n            if warehouse.stock_set.count() == number_of_variants:\n                warehouse_ids.append(warehouse.id)\n\n        lookup = Q(id__in=warehouse_ids)\n        # if the stocks can cover the all variants, all C&C warehouses with\n        # `ALL_WAREHOUSES` option should be returned, as there is an option\n        # to ship the products to this point from another warehouse\n        stocks_count = len(set(stocks_qs.values_list(\"product_variant_id\", flat=True)))\n        if stocks_count == number_of_variants:\n            lookup |= Q(\n                click_and_collect_option=WarehouseClickAndCollectOption.ALL_WAREHOUSES\n            )\n        return warehouses_for_channel.filter(lookup)\n\n    def applicable_for_click_and_collect(\n        self,\n        lines_qs: QuerySet[CheckoutLine] | QuerySet[OrderLine],\n        channel_id: int,\n    ) -> QuerySet[\"Warehouse\"]:\n        \"\"\"Return Warehouses which support click and collect.\n\n        Note additional check of stocks quantity for given `CheckoutLine`s.\n\n        For WarehouseClickAndCollect.LOCAL, all CheckoutLine items must be available for\n        collection from a single warehouse.\n        For WarehouseClickAndCollect.ALL, each CheckoutLine item must be available\n        for collection from any warehouse. Variants may be collected from different\n        warehouses, and the quantity of a single variant can be split across multiple\n        warehouses.\n        \"\"\"\n        warehouse_cc_option_enum = WarehouseClickAndCollectOption\n        if all(\n            line.variant.is_preorder_active() if line.variant else False\n            for line in lines_qs.select_related(\"variant\").only(\"variant_id\")\n        ):\n            return self._for_channel_click_and_collect(channel_id)\n\n        # prepare the mapping of variant_id to total quantity of this variant\n        # in the order\n        line_variant_id_to_total_qty: dict[int | None, int] = defaultdict(int)\n        for line in lines_qs:\n            line_variant_id_to_total_qty[line.variant_id] += line.quantity\n\n        number_of_variants = len(line_variant_id_to_total_qty)\n        warehouses_for_channel = self.for_channel(channel_id)\n\n        # Fetch the stocks for the variants in the order\n        stocks_qs = (\n            Stock.objects.using(self.db)\n            .filter(Exists(lines_qs.filter(variant_id=OuterRef(\"product_variant_id\"))))\n            .annotate_available_quantity()\n        )\n\n        stock_ids = []\n        variant_id_to_total_stock_qty: dict[int | None, int] = defaultdict(int)\n        # Filter out the stocks that have enough quantity to fulfill the order\n        # Prepare the mapping of variant_id to the sum of total available quantity of\n        # the given variant from all stocks\n        for stock in stocks_qs:\n            if (\n                stock.available_quantity\n                >= line_variant_id_to_total_qty[stock.product_variant_id]\n            ):\n                stock_ids.append(stock.id)\n            variant_id_to_total_stock_qty[stock.product_variant_id] += (\n                stock.available_quantity\n            )\n\n        if stock_ids:\n            # Find out warehouses that can cover the order from a single warehouse\n            stocks = Stock.objects.filter(id__in=stock_ids)\n            warehouses = warehouses_for_channel._cc_points_for_stocks(stocks).only(\"id\")\n            warehouse_ids = []\n            for warehouse in warehouses:\n                if warehouse.stock_set.count() == number_of_variants:\n                    warehouse_ids.append(warehouse.id)\n\n            # if there is any valid local warehouse it means that it is possible\n            # to ship products to any warehouse with `all warehouses` option\n            if warehouse_ids:\n                return warehouses_for_channel.filter(\n                    Q(id__in=warehouse_ids)\n                    | Q(\n                        click_and_collect_option=warehouse_cc_option_enum.ALL_WAREHOUSES\n                    )\n                )\n\n        # Check if the ordered line quantities can be fulfilled using stock from\n        # different warehouses.\n        if len(variant_id_to_total_stock_qty) == number_of_variants and all(\n            variant_id_to_total_stock_qty[variant_id] >= variant_total_qty\n            for variant_id, variant_total_qty in line_variant_id_to_total_qty.items()\n        ):\n            return warehouses_for_channel.filter(\n                click_and_collect_option=warehouse_cc_option_enum.ALL_WAREHOUSES\n            )\n        return self.none()\n\n    def _cc_points_for_stocks(self, stocks_qs: QuerySet[\"Stock\"]):\n        return (\n            self.filter(Exists(stocks_qs.filter(warehouse_id=OuterRef(\"id\"))))\n            .exclude(click_and_collect_option=WarehouseClickAndCollectOption.DISABLED)\n            .prefetch_related(Prefetch(\"stock_set\", queryset=stocks_qs))\n        )\n\n    def _for_channel_click_and_collect(self, channel_id: int) -> QuerySet[\"Warehouse\"]:\n        return self.for_channel(channel_id).filter(\n            click_and_collect_option__in=[\n                WarehouseClickAndCollectOption.LOCAL_STOCK,\n                WarehouseClickAndCollectOption.ALL_WAREHOUSES,\n            ]\n        )\n\n\nclass ChannelWarehouse(SortableModel):\n    channel = models.ForeignKey(\n        Channel, related_name=\"channelwarehouse\", on_delete=models.CASCADE\n    )\n    warehouse = models.ForeignKey(\n        \"Warehouse\", related_name=\"channelwarehouse\", on_delete=models.CASCADE\n    )\n\n    class Meta:\n        unique_together = ((\"channel\", \"warehouse\"),)\n        ordering = (\"sort_order\", \"pk\")\n\n    def get_ordering_queryset(self):\n        return self.channel.channelwarehouse.all()\n\n\nWarehouseManager = models.Manager.from_queryset(WarehouseQueryset)\n\n\nclass Warehouse(ModelWithMetadata, ModelWithExternalReference):\n    id = models.UUIDField(default=uuid.uuid4, primary_key=True)\n    name = models.CharField(max_length=250)\n    slug = models.SlugField(max_length=255, unique=True, allow_unicode=True)\n    channels = models.ManyToManyField(\n        Channel, related_name=\"warehouses\", through=ChannelWarehouse\n    )\n    shipping_zones = models.ManyToManyField(\n        ShippingZone, blank=True, related_name=\"warehouses\"\n    )\n    address = models.ForeignKey(Address, on_delete=models.PROTECT)\n    email = models.EmailField(blank=True, default=\"\")\n    click_and_collect_option = models.CharField(\n        max_length=30,\n        choices=WarehouseClickAndCollectOption.CHOICES,\n        default=WarehouseClickAndCollectOption.DISABLED,\n    )\n    is_private = models.BooleanField(default=True)\n\n    objects = WarehouseManager()\n\n    class Meta(ModelWithMetadata.Meta):\n        ordering = (\"-slug\",)\n        indexes = [\n            *ModelWithMetadata.Meta.indexes,\n            BTreeIndex(\n                name=\"click_and_collect_option_idx\",\n                fields=[\"click_and_collect_option\"],\n            ),\n        ]\n\n    def __str__(self):\n        return self.name\n\n    @property\n    def countries(self) -> set[str]:\n        shipping_zones = self.shipping_zones.all()\n        return set(itertools.chain(*[zone.countries for zone in shipping_zones]))\n\n    def delete(self, *args, **kwargs):\n        address = self.address\n        super().delete(*args, **kwargs)\n        address.delete()\n\n\nclass StockQuerySet(models.QuerySet[\"Stock\"]):\n    def annotate_available_quantity(self) -> QuerySet[StockWithAvailableQuantity]:\n        allocation_quantity = (\n            Allocation.objects.filter(stock_id=OuterRef(\"id\"))\n            .values(\"stock_id\")\n            .annotate(total_allocated_quantity=Sum(\"quantity_allocated\"))\n            .values(\"total_allocated_quantity\")\n        )\n        return cast(\n            QuerySet[StockWithAvailableQuantity],\n            self.annotate(\n                available_quantity=F(\"quantity\")\n                - Coalesce(\n                    Subquery(allocation_quantity),\n                    0,\n                )\n            ),\n        )\n\n    def annotate_reserved_quantity(self):\n        return self.annotate(\n            reserved_quantity=Coalesce(\n                Sum(\n                    \"reservations__quantity_reserved\",\n                    filter=Q(reservations__reserved_until__gt=timezone.now()),\n                ),\n                0,\n            )\n        )\n\n    def for_channel_and_click_and_collect(self, channel_slug: str):\n        \"\"\"Return the stocks for a given channel for a click and collect.\n\n        The click and collect warehouses don't have to be assigned to the shipping zones\n        so all stocks for a given channel are returned.\n        \"\"\"\n        WarehouseChannel = Channel.warehouses.through\n\n        channels = Channel.objects.filter(slug=channel_slug).values(\"pk\")\n\n        warehouse_channels = WarehouseChannel.objects.filter(\n            Exists(channels.filter(pk=OuterRef(\"channel_id\")))\n        ).values(\"warehouse_id\")\n\n        return self.select_related(\"product_variant\").filter(\n            Exists(warehouse_channels.filter(warehouse_id=OuterRef(\"warehouse_id\")))\n        )\n\n    def for_channel_and_country(\n        self,\n        channel_slug: str,\n        country_code: str | None = None,\n        include_cc_warehouses: bool = False,\n    ):\n        \"\"\"Get stocks for given channel and country_code.\n\n        The returned stocks, must be in warehouse that is available in provided channel\n        and in the shipping zone that is available in the given channel and country.\n        When the country_code is not provided or include_cc_warehouses is set to True,\n        also the stocks from collection point warehouses allowed in given channel are\n        returned.\n        \"\"\"\n        ShippingZoneChannel = Channel.shipping_zones.through\n        WarehouseShippingZone = ShippingZone.warehouses.through\n        WarehouseChannel = Channel.warehouses.through\n\n        channels = Channel.objects.filter(slug=channel_slug).values(\"pk\")\n\n        shipping_zone_channels = ShippingZoneChannel.objects.filter(\n            Exists(channels.filter(pk=OuterRef(\"channel_id\")))\n        )\n        warehouse_channels = WarehouseChannel.objects.filter(\n            Exists(channels.filter(pk=OuterRef(\"channel_id\")))\n        ).values(\"warehouse_id\")\n\n        cc_warehouses = Warehouse.objects.none()\n        if country_code:\n            shipping_zones = ShippingZone.objects.filter(\n                countries__contains=country_code\n            ).values(\"pk\")\n            shipping_zone_channels = shipping_zone_channels.filter(\n                Exists(shipping_zones.filter(pk=OuterRef(\"shippingzone_id\")))\n            )\n        if not country_code or include_cc_warehouses:\n            # when the country code is not provided we should also include\n            # the collection point warehouses\n            cc_warehouses = Warehouse.objects.filter(\n                Exists(warehouse_channels.filter(warehouse_id=OuterRef(\"id\"))),\n                click_and_collect_option__in=[\n                    WarehouseClickAndCollectOption.LOCAL_STOCK,\n                    WarehouseClickAndCollectOption.ALL_WAREHOUSES,\n                ],\n            )\n\n        shipping_zone_channels.values(\"shippingzone_id\")\n\n        warehouse_shipping_zones = WarehouseShippingZone.objects.filter(\n            Exists(\n                shipping_zone_channels.filter(\n                    shippingzone_id=OuterRef(\"shippingzone_id\")\n                )\n            ),\n            Exists(warehouse_channels.filter(warehouse_id=OuterRef(\"warehouse_id\"))),\n        ).values(\"warehouse_id\")\n        return self.select_related(\"product_variant\").filter(\n            Exists(\n                warehouse_shipping_zones.filter(warehouse_id=OuterRef(\"warehouse_id\"))\n            )\n            | Exists(cc_warehouses.filter(id=OuterRef(\"warehouse_id\")))\n        )\n\n    def get_variant_stocks_for_country(\n        self, country_code: str, channel_slug: str, product_variant: ProductVariant\n    ):\n        \"\"\"Return the stock information about the a stock for a given country.\n\n        Note it will raise a 'Stock.DoesNotExist' exception if no such stock is found.\n        \"\"\"\n        return self.for_channel_and_country(channel_slug, country_code).filter(\n            product_variant=product_variant\n        )\n\n    def get_variants_stocks_for_country(\n        self,\n        country_code: str,\n        channel_slug: str,\n        products_variants: Iterable[ProductVariant],\n    ):\n        \"\"\"Return the stock information about the a stock for a given country.\n\n        Note it will raise a 'Stock.DoesNotExist' exception if no such stock is found.\n        \"\"\"\n        return self.for_channel_and_country(channel_slug, country_code).filter(\n            product_variant__in=products_variants\n        )\n\n    def get_product_stocks_for_country_and_channel(\n        self, country_code: str, channel_slug: str, product: Product\n    ):\n        return self.for_channel_and_country(channel_slug, country_code).filter(\n            product_variant__product_id=product.pk\n        )\n\n\nStockManager = models.Manager.from_queryset(StockQuerySet)\n\n\nclass Stock(models.Model):\n    warehouse = models.ForeignKey(Warehouse, null=False, on_delete=models.CASCADE)\n    product_variant = models.ForeignKey(\n        ProductVariant, null=False, on_delete=models.CASCADE, related_name=\"stocks\"\n    )\n    quantity = models.IntegerField(default=0)\n    quantity_allocated = models.IntegerField(default=0)\n\n    objects = StockManager()\n\n    class Meta:\n        unique_together = [[\"warehouse\", \"product_variant\"]]\n        ordering = (\"pk\",)\n\n    def increase_stock(self, quantity: int, commit: bool = True):\n        \"\"\"Return given quantity of product to a stock.\"\"\"\n        self.quantity = F(\"quantity\") + quantity\n        if commit:\n            self.save(update_fields=[\"quantity\"])\n\n    def decrease_stock(self, quantity: int, commit: bool = True):\n        self.quantity = F(\"quantity\") - quantity\n        if commit:\n            self.save(update_fields=[\"quantity\"])\n\n\nclass AllocationQueryset(models.QuerySet[\"Allocation\"]):\n    def annotate_stock_available_quantity(self):\n        return self.annotate(\n            stock_available_quantity=F(\"stock__quantity\")\n            - Coalesce(Sum(\"stock__allocations__quantity_allocated\"), 0)\n        )\n\n    def available_quantity_for_stock(self, stock: \"Stock\"):\n        allocated_quantity = (\n            self.filter(stock=stock).aggregate(Sum(\"quantity_allocated\"))[\n                \"quantity_allocated__sum\"\n            ]\n            or 0\n        )\n        return max(stock.quantity - allocated_quantity, 0)\n\n\nAllocationManager = models.Manager.from_queryset(AllocationQueryset)\n\n\nclass Allocation(models.Model):\n    order_line = models.ForeignKey(\n        OrderLine,\n        null=False,\n        blank=False,\n        on_delete=models.CASCADE,\n        related_name=\"allocations\",\n    )\n    stock = models.ForeignKey(\n        Stock,\n        null=False,\n        blank=False,\n        on_delete=models.CASCADE,\n        related_name=\"allocations\",\n    )\n    quantity_allocated = models.PositiveIntegerField(default=0)\n\n    objects = AllocationManager()\n\n    class Meta:\n        unique_together = [[\"order_line\", \"stock\"]]\n        ordering = (\"pk\",)\n\n\nclass PreorderAllocation(models.Model):\n    order_line = models.ForeignKey(\n        OrderLine,\n        null=False,\n        blank=False,\n        on_delete=models.CASCADE,\n        related_name=\"preorder_allocations\",\n    )\n    quantity = models.PositiveIntegerField(default=0)\n    product_variant_channel_listing = models.ForeignKey(\n        ProductVariantChannelListing,\n        null=False,\n        blank=False,\n        on_delete=models.CASCADE,\n        related_name=\"preorder_allocations\",\n    )\n\n    class Meta:\n        unique_together = [[\"order_line\", \"product_variant_channel_listing\"]]\n        ordering = (\"pk\",)\n\n\nT = TypeVar(\"T\", bound=models.Model)\n\n\nclass ReservationQuerySet(models.QuerySet[T]):\n    def not_expired(self):\n        return self.filter(reserved_until__gt=timezone.now())\n\n    def exclude_checkout_lines(self, checkout_lines: Iterable[CheckoutLine] | None):\n        if checkout_lines:\n            return self.exclude(checkout_line__in=checkout_lines)\n\n        return self\n\n\nReservationManager = models.Manager.from_queryset(ReservationQuerySet)\n\n\nclass PreorderReservation(models.Model):\n    checkout_line = models.ForeignKey(\n        CheckoutLine,\n        null=False,\n        blank=False,\n        on_delete=models.CASCADE,\n        related_name=\"preorder_reservations\",\n    )\n    product_variant_channel_listing = models.ForeignKey(\n        ProductVariantChannelListing,\n        null=False,\n        blank=False,\n        on_delete=models.CASCADE,\n        related_name=\"preorder_reservations\",\n    )\n    quantity_reserved = models.PositiveIntegerField(default=0)\n    reserved_until = models.DateTimeField()\n\n    objects = ReservationManager()\n\n    class Meta:\n        unique_together = [[\"checkout_line\", \"product_variant_channel_listing\"]]\n        indexes = [\n            models.Index(fields=[\"checkout_line\", \"reserved_until\"]),\n        ]\n        ordering = (\"pk\",)\n\n\nclass Reservation(models.Model):\n    checkout_line = models.ForeignKey(\n        CheckoutLine,\n        null=False,\n        blank=False,\n        on_delete=models.CASCADE,\n        related_name=\"reservations\",\n    )\n    stock = models.ForeignKey(\n        Stock,\n        null=False,\n        blank=False,\n        on_delete=models.CASCADE,\n        related_name=\"reservations\",\n    )\n    quantity_reserved = models.PositiveIntegerField(default=0)\n    reserved_until = models.DateTimeField()\n\n    objects = ReservationManager()\n\n    class Meta:\n        unique_together = [[\"checkout_line\", \"stock\"]]\n        indexes = [\n            models.Index(fields=[\"checkout_line\", \"reserved_until\"]),\n        ]\n        ordering = (\"pk\",)\n",
      "line": 323
    }
  }
]